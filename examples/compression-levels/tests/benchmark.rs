//! Benchmark zstd compression across all 22 levels using the Silesia corpus.
//!
//! This test is marked `#[ignore]` and must be run explicitly.
//! Use release mode for accurate measurements:
//!
//!     cargo test -p example-compression-levels --release --test benchmark -- --ignored --nocapture
//!
//! Results are saved directly to `templates/content/benchmark-data.typ`.

use std::fs;
use std::io::{Read, Write};
use std::path::PathBuf;
use std::time::Instant;

const SILESIA_URL: &str = "https://sun.aei.polsl.pl/~sdeor/corpus/silesia.zip";
const WARMUP: usize = 1;
const ITERATIONS: usize = 5;

#[test]
#[ignore]
fn benchmark_zstd_levels() {
    let data = prepare_silesia_data();
    let data_size_mb = data.len() as f64 / (1024.0 * 1024.0);

    let cpu = get_cpu_name();

    let mut levels = Vec::new();
    let mut ratios = Vec::new();
    let mut comp_speed_medians = Vec::new();
    let mut decomp_speed_medians = Vec::new();
    let mut comp_speed_all = Vec::new();
    let mut decomp_speed_all = Vec::new();

    for level in 1..=22 {
        eprint!("Level {level:>2}/22 ...");
        levels.push(level);

        // Warmup
        let compressed = zstd::encode_all(data.as_slice(), level).unwrap();
        let ratio = data.len() as f64 / compressed.len() as f64;
        ratios.push(round3(ratio));

        for _ in 1..WARMUP {
            let _ = zstd::encode_all(data.as_slice(), level).unwrap();
        }
        let _ = zstd::decode_all(compressed.as_slice()).unwrap();

        // Compression benchmark
        let mut comp_speeds = Vec::new();
        for _ in 0..ITERATIONS {
            let start = Instant::now();
            let _ = zstd::encode_all(data.as_slice(), level).unwrap();
            let elapsed = start.elapsed().as_secs_f64();
            comp_speeds.push(round1(data_size_mb / elapsed));
        }
        comp_speeds.sort_by(|a, b| a.partial_cmp(b).unwrap());
        let comp_median = comp_speeds[ITERATIONS / 2];

        // Decompression benchmark
        let mut decomp_speeds = Vec::new();
        for _ in 0..ITERATIONS {
            let start = Instant::now();
            let _ = zstd::decode_all(compressed.as_slice()).unwrap();
            let elapsed = start.elapsed().as_secs_f64();
            decomp_speeds.push(round1(data_size_mb / elapsed));
        }
        decomp_speeds.sort_by(|a, b| a.partial_cmp(b).unwrap());
        let decomp_median = decomp_speeds[ITERATIONS / 2];

        eprintln!(
            "  ratio={:.3}  comp={:.1} MB/s  decomp={:.1} MB/s",
            ratio, comp_median, decomp_median
        );

        comp_speed_medians.push(comp_median);
        decomp_speed_medians.push(decomp_median);
        comp_speed_all.push(comp_speeds);
        decomp_speed_all.push(decomp_speeds);
    }

    // Build typst data file content
    let mut out = String::new();
    out.push_str("// Auto-generated by benchmark test. Do not edit manually.\n");
    out.push_str(&format!(
        "// Run: cargo test -p example-compression-levels --release --test benchmark -- --ignored --nocapture\n"
    ));
    out.push_str(&format!(
        "// Silesia corpus ({:.1} MB), zstd 0.13, {} iterations\n",
        data_size_mb, ITERATIONS
    ));
    out.push('\n');
    out.push_str(&format!("#let levels = ({})\n", fmt_ints(&levels)));
    out.push_str(&format!("#let ratio = ({})\n", fmt_floats(&ratios, 3)));
    out.push_str(&format!(
        "#let comp_speed = ({})\n",
        fmt_floats(&comp_speed_medians, 1)
    ));
    out.push_str(&format!(
        "#let decomp_speed = ({})\n",
        fmt_floats(&decomp_speed_medians, 1)
    ));
    out.push_str(&format!(
        "#let comp_speed_all = ({})\n",
        fmt_nested_floats(&comp_speed_all, 1)
    ));
    out.push_str(&format!(
        "#let decomp_speed_all = ({})\n",
        fmt_nested_floats(&decomp_speed_all, 1)
    ));
    out.push_str(&format!(
        "#let footer-text = \"Measured on {} --- Silesia corpus ({:.1} MB), {} iterations, zstd 0.13\"\n",
        cpu, data_size_mb, ITERATIONS
    ));

    // Write to benchmark-data.typ
    let out_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("templates")
        .join("content")
        .join("benchmark-data.typ");
    fs::write(&out_path, &out).unwrap();
    eprintln!("Saved to {}", out_path.display());
}

// ---------------------------------------------------------------------------
// Formatting helpers
// ---------------------------------------------------------------------------

fn fmt_ints(v: &[i32]) -> String {
    v.iter()
        .map(|x| x.to_string())
        .collect::<Vec<_>>()
        .join(", ")
}

fn fmt_floats(v: &[f64], decimals: usize) -> String {
    v.iter()
        .map(|x| format!("{x:.decimals$}"))
        .collect::<Vec<_>>()
        .join(", ")
}

fn fmt_nested_floats(v: &[Vec<f64>], decimals: usize) -> String {
    v.iter()
        .map(|inner| format!("({})", fmt_floats(inner, decimals)))
        .collect::<Vec<_>>()
        .join(", ")
}

// ---------------------------------------------------------------------------
// Rounding
// ---------------------------------------------------------------------------

fn round1(v: f64) -> f64 {
    (v * 10.0).round() / 10.0
}

fn round3(v: f64) -> f64 {
    (v * 1000.0).round() / 1000.0
}

// ---------------------------------------------------------------------------
// System info
// ---------------------------------------------------------------------------

fn get_cpu_name() -> String {
    #[cfg(target_os = "macos")]
    {
        let output = std::process::Command::new("sysctl")
            .args(["-n", "machdep.cpu.brand_string"])
            .output();
        if let Ok(out) = output {
            return String::from_utf8_lossy(&out.stdout).trim().to_string();
        }
    }
    #[cfg(target_os = "linux")]
    {
        if let Ok(cpuinfo) = std::fs::read_to_string("/proc/cpuinfo") {
            if let Some(line) = cpuinfo.lines().find(|l| l.starts_with("model name")) {
                return line
                    .split(':')
                    .nth(1)
                    .unwrap_or("unknown")
                    .trim()
                    .to_string();
            }
        }
    }
    "unknown".to_string()
}

// ---------------------------------------------------------------------------
// Silesia corpus download & load
// ---------------------------------------------------------------------------

fn prepare_silesia_data() -> Vec<u8> {
    let cache_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("target")
        .join("silesia");
    fs::create_dir_all(&cache_dir).unwrap();

    let zip_path = cache_dir.join("silesia.zip");

    if !zip_path.exists() {
        eprintln!("Downloading Silesia corpus...");
        download_file(SILESIA_URL, &zip_path);
        eprintln!(
            "Downloaded {} bytes",
            fs::metadata(&zip_path).unwrap().len()
        );
    } else {
        eprintln!("Using cached Silesia corpus");
    }

    // Load entire corpus (no sampling)
    eprintln!("Loading full corpus...");
    let file = fs::File::open(&zip_path).unwrap();
    let mut archive = zip::ZipArchive::new(file).unwrap();
    let mut buffer = Vec::new();

    for i in 0..archive.len() {
        let mut entry = archive.by_index(i).unwrap();
        if !entry.is_file() {
            continue;
        }
        let mut chunk = Vec::new();
        entry.read_to_end(&mut chunk).unwrap();
        buffer.extend_from_slice(&chunk);
    }

    eprintln!("Loaded {:.1} MB", buffer.len() as f64 / (1024.0 * 1024.0));
    buffer
}

fn download_file(url: &str, path: &PathBuf) {
    let response = ureq::get(url).call().unwrap();
    let (_, body) = response.into_parts();
    let mut reader = body.into_reader();
    let mut file = fs::File::create(path).unwrap();
    let mut buf = [0u8; 8192];
    let mut total = 0u64;
    loop {
        let n = reader.read(&mut buf).unwrap();
        if n == 0 {
            break;
        }
        file.write_all(&buf[..n]).unwrap();
        total += n as u64;
        if total % (10 * 1024 * 1024) < 8192 {
            eprint!(
                "\r  {:.1} MB downloaded...",
                total as f64 / (1024.0 * 1024.0)
            );
        }
    }
    eprintln!();
}
